iris$Sepal.Length[1:10]
summary(iris)
quantile(iris$Sepal.Length)
quantile(iris$Sepal.Length, c(0.1, 0.3, 0.65))
var(iris$Sepal.Length)
hist(iris$Sepal.Length)
plot(density(iris$Sepal.Length))
table(iris$Species)
pie(table(iris$Species))
barplot(table(iris$Species))
cov(iris$Sepal.Length, iris$Petal.Length)
cov(iris[,1:4])
cor(iris$Sepal.Length, iris$Petal.Length)
cor(iris[,1:4])
aggregate(Sepal.Length ~ Speices, summary, data=iris)
aggregate(Sepal.Length ~ Species, summary, data=iris)
boxplot(Sepal.Length ~ Species, data=iris, xlab="Species", ylab="Sepal.Length")
with(iris, plot(Sepal.Length, Sepal.Width, col=Species, pch-as.numeric(Species)))
with(iris, plot(Sepal.Length, Sepal.Width, col=Species, pch=as.numeric(iris$Species)))
plot(iris$Sepal.Length, iris$Sepal.Width, col=iris$Species, pch=as.numeric(iris$Species))
plot(jitter(iris$Sepal.Length), jitter(iris$Sepal.Width))
smoothScatter(iris$Sepal.Length, iris$Sepal.Width)
pairs(iris)
library(scatterplot3d)
install.packages(scatterplot3d)
install.packages("scatterplot3d")
library(scatterplot3d)
scatterplot3d(iris$Petal.Width, iris$Sepal.Length, iris$Sepal.Width)
install.packages("rgl")
library(rgl)
library(rgl)
plot3d(iris$Petal.Width, iris$Sepal.Length, iris$Sepal.Width)
distMatrix <- as.matrix(dist(iris[,1:4]))
heatmap(distMatrix)
install.packages("lattice")
library(lattice)
levelplot(Petal.Width~Sepal.Length*Sepal.Width, iris, cuts=9, col.regions=grey.colors(10)[10:1])
install.packages("graphics")
install.packages("graphics")
install.packages("graphics")
install.packages("graphics")
install.packages("graphics")
install.packages("graphics")
install.packages("graphics")
install.packages("graphics")
library(graphics)
filled.contour(volcano.color=terrain.colors, asp=1, plot.axes=contour(volcano, add=T))
filled.contour(volcano, color=terrain.colors, asp=1, plot.axes=contour(volcano, add=T))
persp(volcano, theta=25, phi=30, expand=0.5, col="lightblue")
install.packages("MASS")
library(MASS)
parcoord(iris[1:4], col=iris$Species)
parallelplot(~iris[1:4] | Species, data=iris)
library(lattice)
parallelplot(~iris[1:4] | Species, data=iris)
library(ggplot2)
library(ggplot)
install.packages("ggplot2")
library(ggplot2)
qplot(Sepal.Length, Sepal.Width, data=iris, facets=Species ~.)
x <- 1:50
plot(x, log(x))
graphics.off()
x <- -20:20
plot(x, x^2)
sink("outputfile.txt")
dim(iris)
install.packages("contrib.url")
dim(iris)
names(iris)
str(iris)
attributes(iris)
iris[1:5, ]
head(iris)
tail(iris)
idx <- sample(1:nrow(iris), 5)
idx
iris[idx, ]
iris[1:10, "Sepal.Length"]
iris[1:10, 1]
iris$Sepal.Length[1:10]
summary(iris)
quantile(iris$Sepal.Length)
quantile(iris$Sepal.Length, c(0.1, 0.3, 0.65))
var(iris$Sepal.Length)
hist(iris$Sepal.Length)
plot(density(iris$Sepal.Length))
table(iris$Species)
pie(table(iris$Species))
barplot(table(iris$Species))
cov(iris$Sepal.Length, iris$Petal.Length)
cov(iris[,1:4])
cor(iris$Sepal.Length, iris$Petal.Length)
cor(iris[,1:4])
aggregate(Sepal.Length ~ Species, summary, data=iris)
boxplot(Sepal.Length ~ Species, data=iris, xlab="Species", ylab="Sepal.Length")
with(iris, plot(Sepal.Length, Sepal.Width, col=Species, pch=as.numeric(iris$Species)))
plot(iris$Sepal.Length, iris$Sepal.Width, col=iris$Species, pch=as.numeric(iris$Species))
plot(jitter(iris$Sepal.Length), jitter(iris$Sepal.Width))
smoothScatter(iris$Sepal.Length, iris$Sepal.Width)
pairs(iris)
install.packages("scatterplot3d")
library(scatterplot3d)
scatterplot3d(iris$Petal.Width, iris$Sepal.Length, iris$Sepal.Width)
install.packages("rgl")
library(rgl)
plot3d(iris$Petal.Width, iris$Sepal.Length, iris$Sepal.Width)
distMatrix <- as.matrix(dist(iris[,1:4]))
heatmap(distMatrix)
install.packages("lattice")
library(lattice)
levelplot(Petal.Width~Sepal.Length*Sepal.Width, iris, cuts=9, col.regions=grey.colors(10)[10:1])
install.packages("graphics")
library(graphics)
filled.contour(volcano, color=terrain.colors, asp=1, plot.axes=contour(volcano, add=T))
persp(volcano, theta=25, phi=30, expand=0.5, col="lightblue")
install.packages("MASS")
library(MASS)
parcoord(iris[1:4], col=iris$Species)
parallelplot(~iris[1:4] | Species, data=iris)
install.packages("ggplot2")
library(ggplot2)
qplot(Sepal.Length, Sepal.Width, data=iris, facets=Species ~.)
pdf("myplot.pdf")
x <- 1:50
plot(x, log(x))
graphics.off()
postscript("myplot2.ps")
x <- -20:20
plot(x, x^2)
graphics.off()
dev.off()
install.packages("lattice")
dim(iris)
names(iris)
str(iris)
attributes(iris)
iris[1:5, ]
head(iris)
tail(iris)
idx <- sample(1:nrow(iris), 5)
idx
iris[idx, ]
iris[1:10, "Sepal.Length"]
iris[1:10, 1]
iris$Sepal.Length[1:10]
summary(iris)
quantile(iris$Sepal.Length)
quantile(iris$Sepal.Length, c(0.1, 0.3, 0.65))
var(iris$Sepal.Length)
hist(iris$Sepal.Length)
plot(density(iris$Sepal.Length))
table(iris$Species)
pie(table(iris$Species))
barplot(table(iris$Species))
cov(iris$Sepal.Length, iris$Petal.Length)
cov(iris[,1:4])
cor(iris$Sepal.Length, iris$Petal.Length)
cor(iris[,1:4])
aggregate(Sepal.Length ~ Species, summary, data=iris)
boxplot(Sepal.Length ~ Species, data=iris, xlab="Species", ylab="Sepal.Length")
with(iris, plot(Sepal.Length, Sepal.Width, col=Species, pch=as.numeric(iris$Species)))
plot(iris$Sepal.Length, iris$Sepal.Width, col=iris$Species, pch=as.numeric(iris$Species))
plot(jitter(iris$Sepal.Length), jitter(iris$Sepal.Width))
smoothScatter(iris$Sepal.Length, iris$Sepal.Width)
pairs(iris)
install.packages("scatterplot3d")
library(scatterplot3d)
scatterplot3d(iris$Petal.Width, iris$Sepal.Length, iris$Sepal.Width)
install.packages("rgl")
library(rgl)
plot3d(iris$Petal.Width, iris$Sepal.Length, iris$Sepal.Width)
distMatrix <- as.matrix(dist(iris[,1:4]))
heatmap(distMatrix)
install.packages("lattice")
library(lattice)
levelplot(Petal.Width~Sepal.Length*Sepal.Width, iris, cuts=9, col.regions=grey.colors(10)[10:1])
install.packages("graphics")
library(graphics)
filled.contour(volcano, color=terrain.colors, asp=1, plot.axes=contour(volcano, add=T))
persp(volcano, theta=25, phi=30, expand=0.5, col="lightblue")
install.packages("MASS")
library(MASS)
parcoord(iris[1:4], col=iris$Species)
parallelplot(~iris[1:4] | Species, data=iris)
install.packages("ggplot2")
library(ggplot2)
qplot(Sepal.Length, Sepal.Width, data=iris, facets=Species ~.)
pdf("myplot.pdf")
x <- 1:50
plot(x, log(x))
graphics.off()
postscript("myplot2.ps")
x <- -20:20
plot(x, x^2)
graphics.off()
dev.off()
install.packages("graphics")
require(stats) # for median
med.att <- apply(attitude, 2, median)
med.att
sweep(data.matrix(attitude), 2, med.att)  # subtract the column medians
A <- array(1:24, dim = 4:2)
A
sweep(A, 1, 5)
# load tweets into R
library(twitteR)
load(file = "rdmTweets-201306.RData")
length(tweets) = 200
(n.tweet <- length(tweets))
tweets[1:5]
tweets[11:15]
# Text Cleaning
# convert tweets to a data frame
# tweets.df <- do.call("rbind", lapply(tweets, as.data.frame))
tweets.df <- twListToDF(tweets)
dim(tweets.df)
## Loading required package: NLP
library(tm)
# build a corpus, and specify the source to be character vectors
KCorpus <- Corpus(VectorSource(tweets.df$text))
# convert to lower case
# tm v0.6
KCorpus <- tm_map(KCorpus, content_transformer(tolower))
# tm v0.5-10
# KCorpus <- tm_map(KCorpus, tolower)
# remove URLs
removeURL <- function(x) gsub("http[^[:space:]]*", "", x)
# tm v0.6
KCorpus <- tm_map(KCorpus, content_transformer(removeURL))
# tm v0.5-10
# KCorpus <- tm_map(KCorpus, removeURL)
# remove anything other than English letters or space
removeNumPunct <- function(x) gsub("[^[:alpha:][:space:]]*", "", x)
KCorpus <- tm_map(KCorpus, content_transformer(removeNumPunct))
# remove punctuation
KCorpus <- tm_map(KCorpus, removePunctuation)
# remove numbers
KCorpus <- tm_map(KCorpus, removeNumbers)
# add two extra stop words: "available" and "via"
myStopwords <- c(stopwords("english"), "available", "via")
# remove "r" and "big" from stopwords
myStopwords <- setdiff(myStopwords, c("r", "big"))
# remove stopwords from corpus
KCorpus <- tm_map(KCorpus, removeWords, myStopwords)
# remove extra whitespace
KCorpus <- tm_map(KCorpus, stripWhitespace)
inspect(KCorpus[11:15])
# keep a copy of corpus to use later as a dictionary for stem completion
KCorpusCopy <- KCorpus
# stem words
KCorpus <- tm_map(KCorpus, stemDocument)
# inspect documents (tweets) numbered 11 to 15
# inspect(KCorpus[11:15])
# The code below is used for to make text fit for paper width
for (i in 11:15) {
cat(paste("[[", i, "]] ", sep=""))
writeLines(strwrap(KCorpus[[i]], width=73))
}
# inspect the first 5 documents (tweets)
# inspect(KCorpus[1:5])
# The code below is used for to make text fit for paper width
for (i in 11:15) {
cat(paste0("[", i, "] "))
writeLines(strwrap(as.character(KCorpus[[i]]), 60))
}
# tm v0.5-10
# KCorpus <- tm_map(KCorpus, stemCompletion)
# tm v0.6
stemCompletion2 <- function(x, dictionary) {
x <- unlist(strsplit(as.character(x), " "))
# Unexpectedly, stemCompletion completes an empty string to
# a word in dictionary. Remove empty string to avoid above issue.
x <- x[x != ""]
x <- stemCompletion(x, dictionary=dictionary)
x <- paste(x, sep="", collapse=" ")
PlainTextDocument(stripWhitespace(x))
}
KCorpus <- lapply(KCorpus, stemCompletion2, dictionary=KCorpusCopy)
KCorpus <- Corpus(VectorSource(KCorpus))
inspect(KCorpus[11:15])
# count frequency of "mining"
miningCases <- lapply(KCorpusCopy,
function(x) { grep(as.character(x), pattern = "\\<mining")} )
sum(unlist(miningCases))
# count frequency of "miner"
minerCases <- lapply(KCorpusCopy,
function(x) {grep(as.character(x), pattern = "\\<miner")} )
sum(unlist(minerCases))
# replace "miner" with "mining"
KCorpus <- tm_map(KCorpus, content_transformer(gsub),
pattern = "miners", replacement = "mining")
tdm <- TermDocumentMatrix(KCorpus, control=list(wordLengths=c(1,Inf)))
tdm
idx <- which(dimnames(tdm)$Terms == "r")
inspect(tdm[idx+(0:5),101:110])
tdm <- TermDocumentMatrix(KCorpus, control=list(minWordLength=1))
# inspect frequent words
findFreqTerms(tdm, lowfreq=10)
termFrequency <- rowSums(as.matrix(tdm))
termFrequency <- subset(termFrequency, termFrequency>=10)
library(ggplot2)
df <- data.frame(term=names(termFrequency), freq=termFrequency)
ggplot(df, aes(x=term, y=freq)) + geom_bar(stat="identity") +
xlab("Terms") + ylab("Count") + coord_flip()
barplot(termFrequency, las=2)
# which words are associated with 'r'?
findAssocs(tdm, "r", 0.2)
# which words are associated with 'mining'?
findAssocs(tdm, "mining", 0.25)
install.packages("wordcloud")
library(wordcloud)
m <- as.matrix(tdm)
# calculate the frequency of words and sort it descendingly by frequency
wordFreq <- sort(rowSums(m), decreasing=TRUE)
# colors
pal <- brewer.pal(9, "BuGn")
pal <- pal[-(1:4)]
# word cloud
set.seed(375) # to make it reproducible
grayLevels <- gray( (wordFreq+10) / (max(wordFreq)+10) )
wordcloud(words=names(wordFreq), freq=wordFreq, min.freq=3, random.order=F,
colors=pal)
###Clustering
# remove sparse terms
tdm2 <- removeSparseTerms(tdm, sparse=0.95)
m2 <- as.matrix(tdm2)
# cluster terms
distMatrix <- dist(scale(m2))
fit <- hclust(distMatrix, method="ward.D")
plot(fit)        ###print
# cut tree into 10 clusters
rect.hclust(fit, k=10)
(groups <- cutree(fit, k=10))
# transpose the matrix to cluster documents (tweets)
m3 <- t(m2)
# set a fixed random seed
set.seed(122)
# k-means clustering of tweets
k <- 8
kmeansResult <- kmeans(m3, k)
# cluster centers
round(kmeansResult$centers, digits=3)
for (i in 1:k) {
cat(paste("cluster ", i, ": ", sep=""))
s <- sort(kmeansResult$centers[i,], decreasing=T)
cat(names(s)[1:3], "\n")
# print the tweets of every cluster
# print(rdmTweets[which(kmeansResult$cluster==i)])
}
install.packages("fpc")
library(fpc)
# partitioning around medoids with estimation of number of clusters
pamResult <- pamk(m3, metric="manhattan")
# number of clusters identified
(k <- pamResult$nc)
pamResult <- pamResult$pamobject
# print cluster medoids
for (i in 1:k) {
cat(paste("cluster", i, ": "))
cat(colnames(pamResult$medoids)[which(pamResult$medoids[i,]==1)], "\n")
# print tweets in cluster i
# print(rdmTweets[pamResult$clustering==i])
}
# plot clustering result
layout(matrix(c(1,2),2,1)) # set to two graphs per page
plot(pamResult, col.p=pamResult$clustering, color=F, labels=4, lines=0, cex=.8, col.clus=1)
layout(matrix(1)) # change back to one graph per page
iris2 <- iris
iris2$Species <- NULL
(kmeans.result <- kmeans(iris2, 3))
table(iris$Species, kmeans.result$cluster)
plot(iris2[c("Sepal.Length", "Sepal.Width")], col=kmeans.result$cluster)
points(kmeans.result$centers[,c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex=2)
library(fpc)
pamk.result <- pamk(iris2)
pamk.result$nc
table(pamk.result$pamobject$clustering, iris$Species)
layout(matrix(c(1,2),1,2))
plot(pamk.result$pamobject)
layout(matrix(1))
library(cluster)
pam.result <- pam(iris2, 3)
table(pam.result$clustering, iris$Species)
layout(matrix(c(1,2),1,2))
plot(pam.result)
layout(matrix(1))
idx <- sample(1:dim(iris)[1], 40)
irisSample <- iris[idx,]
irisSample$Species <- NULL
hc <- hclust(dist(irisSample), method="ave")
plot(hc, hang=-1, labels=iris$Species[idx])
rect.hclust(hc, k=3)
groups <- cutree(hc, k=3)
iris2 <- iris[-5]
ds <- dbscan(iris2, eps=0, 42, MinPts = 5)
table(dm$cluster, iris$Species)
table(dd$cluster, iris$Species)
table(ds$cluster, iris$Species)
head(iris)
head(iris2)
ds <- dbscan(iris2, eps=0.42, MinPts = 5)
table(ds$cluster, iris$Species)
plot(ds, iris2)
plot(ds, iris2[c(1,4)])
plotcluster(iris2, ds$cluster)
set.seed(435)
idx <- sample(1:nrow(iris), 10)
newData <- iris[idx, -5]
newData <- newData + matrix(runif(10*4, min=0,2), nrow=10, ncol=4)
myPred <- predict(ds, iris2, newData)
plot(iris2[c(1,4)], col=1+ds$cluster)
points(newData[c(1,4)], pch="*", col=1+myPred, cex=3)
table(myPred, iris$Species[idx])
newData <- newData + matrix(runif(10*4, min=0.2), nrow=10, ncol=4)
myPred <- predict(ds, iris2, newData)
plot(iris2[c(1,4)], col=1+ds$cluster)
points(newData[c(1,4)], pch="*", col=1+myPred, cex=3)
table(myPred, iris$Species[idx])
newData <- newData + matrix(runif(10*4, min=0, max=0.2), nrow=10, ncol=4)
myPred <- predict(ds, iris2, newData)
plot(iris2[c(1,4)], col=1+ds$cluster)
points(newData[c(1,4)], pch="*", col=1+myPred, cex=3)
table(myPred, iris$Species[idx])
points(newData[,c(1,4)], pch="*", col=1+myPred, cex=3)
plot(iris2[c(1,4)], col=1+ds$cluster)
points(newData[,c(1,4)], pch="*", col=1+myPred, cex=3)
table(myPred, iris$Species[idx])
table(myPred, iris$Species[idx])
ds <- dbscan(iris2, eps=0.42, MinPts = 5)
myPred <- predict(ds, iris2, newData)
table(myPred, iris$Species[idx])
head(iris)
head(iris2)
iris2 <- iris
head(iris2)
iris2$Species <- NULL
head(iris2)
(kmeans.result <- kmeans(iris2, 3))
table(iris$Species, kmeans.result$cluster)
(kmeans.result <- kmeans(iris2, 3))
table(iris$Species, kmeans.result$cluster)
plot(iris2[c("Sepal.Length", "Sepal.Width")], col=kmeans.result$cluster)
points(kmeans.result$centers[,c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex=2)
library(fpc)
pamk.result <- pamk(iris2)
pamk.result$nc
table(pamk.result$pamobject$clustering, iris$Species)
layout(matrix(c(1,2),1,2))
plot(pamk.result$pamobject)
layout(matrix(1))
library(cluster)
pam.result <- pam(iris2, 3)
table(pam.result$clustering, iris$Species)
layout(matrix(c(1,2),1,2))
plot(pam.result)
layout(matrix(1))
idx <- sample(1:dim(iris)[1], 40)
irisSample <- iris[idx,]
irisSample$Species <- NULL
hc <- hclust(dist(irisSample), method="ave")
plot(hc, hang=-1, labels=iris$Species[idx])
rect.hclust(hc, k=3)
groups <- cutree(hc, k=3)
library(fpc)
iris2 <- iris[-5]
ds <- dbscan(iris2, eps=0.42, MinPts = 5)
table(ds$cluster, iris$Species)
plot(ds, iris2)
plot(ds, iris2[c(1,4)])
plotcluster(iris2, ds$cluster)
set.seed(435)
idx <- sample(1:nrow(iris), 10)
newData <- iris[idx, -5]
newData <- newData + matrix(runif(10*4, min=0, max=0.2), nrow=10, ncol=4)
myPred <- predict(ds, iris2, newData)
plot(iris2[c(1,4)], col=1+ds$cluster)
points(newData[c(1,4)], pch="*", col=1+myPred, cex=3)
table(myPred, iris$Species[idx])
head(diamonds)
library(ggplot2)
head(diamonds)
install.packages("kernlab")
?specc
??specc
?specc
library(kernlab)
library(SamSPECTRAL)
library(kknn)
library(dbscan)
library(cluster)
setwd("~/Learning/Lipscomb MSDS/Data Mining/Final _Project")
digits.full <- read.csv('MNIST/train.csv')
digits.small <- digits.full[1:100,] #make the dataset smaller in order to run it on your laptop
digits.train <- as.matrix(digits.small[,2:785]) #remove the labels from the small dataset for model training
digits.model.specc <- specc(digits.train, centers = 10)
(digits.con_mat.specc <- table(digits.small$label, digits.model.specc[1:100]))
digits.con_mat.specc[1,] / sum(digits.con_mat.specc[1,])
digits.model.km <- kmeans(digits.small[,2:785], 10, nstart=20)
(digits.con_mat.km <- table(digits.small$label, digits.model.km$cluster))
digits.model.sam <- SamSPECTRAL(digits.train[1:100, ], dimensions=c(1,2,3, 4, 5, 6, 7, 8, 9, 10), normal.sigma = 5, separation.factor = 0.7)
(digits.con_mat.sam <- table(digits.small$label, digits.model.sam))
digits.model.db <- dbscan(digits.train, eps=1200, minPts = 4)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.kknn <- specClust(digits.small[,2:785], centers=10)
digits.model.kknn <- specClust(digits.small[,2:785], centers=10)
(digits.con_mat.kknn <- table(digits.small$label, digits.model.kknn$cluster))
kNNdistplot(digits.train, 10) #get the eps for the dbscan model. Need the y value at the elbow on the plot
digits.model.db <- dbscan(digits.train, eps=1700, minPts = 4)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=1700, minPts = 8)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
