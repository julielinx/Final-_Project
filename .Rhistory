head(iris2)
iris2 <- iris
head(iris2)
iris2$Species <- NULL
head(iris2)
(kmeans.result <- kmeans(iris2, 3))
table(iris$Species, kmeans.result$cluster)
(kmeans.result <- kmeans(iris2, 3))
table(iris$Species, kmeans.result$cluster)
plot(iris2[c("Sepal.Length", "Sepal.Width")], col=kmeans.result$cluster)
points(kmeans.result$centers[,c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex=2)
library(fpc)
pamk.result <- pamk(iris2)
pamk.result$nc
table(pamk.result$pamobject$clustering, iris$Species)
layout(matrix(c(1,2),1,2))
plot(pamk.result$pamobject)
layout(matrix(1))
library(cluster)
pam.result <- pam(iris2, 3)
table(pam.result$clustering, iris$Species)
layout(matrix(c(1,2),1,2))
plot(pam.result)
layout(matrix(1))
idx <- sample(1:dim(iris)[1], 40)
irisSample <- iris[idx,]
irisSample$Species <- NULL
hc <- hclust(dist(irisSample), method="ave")
plot(hc, hang=-1, labels=iris$Species[idx])
rect.hclust(hc, k=3)
groups <- cutree(hc, k=3)
library(fpc)
iris2 <- iris[-5]
ds <- dbscan(iris2, eps=0.42, MinPts = 5)
table(ds$cluster, iris$Species)
plot(ds, iris2)
plot(ds, iris2[c(1,4)])
plotcluster(iris2, ds$cluster)
set.seed(435)
idx <- sample(1:nrow(iris), 10)
newData <- iris[idx, -5]
newData <- newData + matrix(runif(10*4, min=0, max=0.2), nrow=10, ncol=4)
myPred <- predict(ds, iris2, newData)
plot(iris2[c(1,4)], col=1+ds$cluster)
points(newData[c(1,4)], pch="*", col=1+myPred, cex=3)
table(myPred, iris$Species[idx])
head(diamonds)
library(ggplot2)
head(diamonds)
install.packages("kernlab")
?specc
??specc
?specc
library(kernlab)
library(SamSPECTRAL)
library(kknn)
library(dbscan)
#use iris dataset. Convert into a matrix to run through specc
iris.train <- as.matrix(iris[,1:4])
#use spectral clustering
iris.model <- specc(iris.train, centers = 3)
(iris_con_mat.specc <- table(iris.model[1:150], iris$Species))
library(cluster)
clusplot(iris, iris.model[1:150], color=T, shade=T, labels=0, lines=0)
#use kmeans clustering
iris.model.km <- kmeans(iris[,1:4], 3, nstart=20)
(iris.con_mat.km <- table(irisCluster$cluster, iris$Species))
clusplot(iris, irisCluster$cluster, color=T, shade=T, labels=0, lines=0)
#use SamSPECTRAL clustering
iris.model.sam <- SamSPECTRAL(iris.train, dimensions=c(1,2,3), normal.sigma = 3, separation.factor = 1.2)
(iris.con_mat.sam <- table(iris.model.sam, iris$Species))
#use bdscan clustering
kNNdistplot(iris.train, 4)
iris.model.db <- dbscan(iris.train, eps=.5, minPts = 4)
(iris.con_mat.db <- table(iris.model.db$cluster, iris$Species))
#use kknn a nearest neighbors algorithm
library(kknn)
iris.model.kknn <- specClust(iris.train, centers=3)
(iris.con_mat.kknn <- table(iris.model.kknn$cluster, iris$Species))
iris.model <- specc(iris.train, centers = 3)
(iris_con_mat.specc <- table(iris.model[1:150], iris$Species))
clusplot(iris, iris.model[1:150], color=T, shade=T, labels=0, lines=0)
iris.model.km <- kmeans(iris[,1:4], 3, nstart=20)
(iris.con_mat.km <- table(iris.model.km$cluster, iris$Species))
clusplot(iris, iris.model.km$cluster, color=T, shade=T, labels=0, lines=0)
iris.model.sam <- SamSPECTRAL(iris.train, dimensions=c(1,2,3), normal.sigma = 3, separation.factor = 1.2)
(iris.con_mat.sam <- table(iris.model.sam, iris$Species))
clusplot(iris, iris.model.sam, color=T, shade=T, labels=0, lines=0)
kNNdistplot(iris.train, 4)
iris.model.db <- dbscan(iris.train, eps=.5, minPts = 4)
(iris.con_mat.db <- table(iris.model.db$cluster, iris$Species))
clusplot(iris, iris.model.db$cluster, color=T, shade=T, labels=0, lines=0)
iris.model.kknn <- specClust(iris.train, centers=3)
(iris.con_mat.kknn <- table(iris.model.kknn$cluster, iris$Species))
clusplot(iris, iris.model.kknn$cluster, color=T, shade=T, labels=0, lines=0)
library(kernlab)
library(SamSPECTRAL)
library(kknn)
library(dbscan)
library(cluster)
#use iris dataset. Convert into a matrix to run through specc
iris.train <- as.matrix(iris[,1:4])
#use spectral clustering
iris.model <- specc(iris.train, centers = 3)
(iris_con_mat.specc <- table(iris.model[1:150], iris$Species))
clusplot(iris, iris.model[1:150], color=T, shade=T, labels=0, lines=0)
#use kmeans clustering
iris.model.km <- kmeans(iris[,1:4], 3, nstart=20)
(iris.con_mat.km <- table(iris.model.km$cluster, iris$Species))
clusplot(iris, iris.model.km$cluster, color=T, shade=T, labels=0, lines=0)
#use SamSPECTRAL clustering
iris.model.sam <- SamSPECTRAL(iris.train, dimensions=c(1,2,3), normal.sigma = 3, separation.factor = 1.2)
(iris.con_mat.sam <- table(iris.model.sam, iris$Species))
clusplot(iris, iris.model.sam, color=T, shade=T, labels=0, lines=0)
#use bdscan clustering
#kNNdistplot(iris.train, 4) #get the eps for the dbscan model. Need the y value at the elbow on the plot
iris.model.db <- dbscan(iris.train, eps=.5, minPts = 4)
(iris.con_mat.db <- table(iris.model.db$cluster, iris$Species))
clusplot(iris, iris.model.db$cluster, color=T, shade=T, labels=0, lines=0)
#use kknn a nearest neighbors algorithm
library(kknn)
iris.model.kknn <- specClust(iris.train, centers=3)
(iris.con_mat.kknn <- table(iris.model.kknn$cluster, iris$Species))
clusplot(iris, iris.model.kknn$cluster, color=T, shade=T, labels=0, lines=0)
?datasets
library(kernlab)
library(SamSPECTRAL)
library(kknn)
library(dbscan)
library(cluster)
setwd("~/Learning/Lipscomb MSDS/Data Mining/Final _Project")
#Read in data. Convert into a matrix to run through specc
digits.full <- read.csv('MNIST/train.csv')
digits.small <- digits.train[1:1000,] #make the dataset smaller in order to run it on your laptop
digits.train <- as.matrix(digits.small[,2:785]) #remove the labels from the small dataset for model training
digits.small <- digits.full[1:1000,] #make the dataset smaller in order to run it on your laptop
digits.train <- as.matrix(digits.small[,2:785]) #remove the labels from the small dataset for model training
digits.model.specc <- specc(digits.train, centers = 10)
(digits_con_mat.specc <- table(digits.model.specc[1:1000], digits.small$label))
clusplot(digits.small, digits.model.specc[1:1000], color=T, shade=T, labels=0, lines=0)
(digits_con_mat.specc <- table(digits.small$label, digits.model.specc[1:1000]))
clusplot(digits.small, digits.model.specc[1:1000], color=T, shade=T, labels=0, lines=0)
digits.model.km <- kmeans(digits.train, 3, nstart=20)
(digits.con_mat.km <- table(digits.small$label, digits.model.km$cluster))
digits.model.km <- kmeans(digits.train, 10, nstart=20)
(digits.con_mat.km <- table(digits.small$label, digits.model.km$cluster))
clusplot(digits, digits.model.km$cluster, color=T, shade=T, labels=0, lines=0)
clusplot(digits.small, digits.model.km$cluster, color=T, shade=T, labels=0, lines=0)
digits.model.sam <- SamSPECTRAL(digits.train, dimensions=c(1,2,3), normal.sigma = 10, separation.factor = 1.2)
(digits.con_mat.sam <- table(digits.small$label, digits.model.sam))
digits.model.sam <- SamSPECTRAL(digits.train, dimensions=c(1,2,3, 4, 5, 6, 7, 8, 9, 10), normal.sigma = 10, separation.factor = 0.7)
digits.model.sam <- SamSPECTRAL(digits.train[1:100, ], dimensions=c(1,2,3, 4, 5, 6, 7, 8, 9, 10), normal.sigma = 10, separation.factor = 0.7)
digits.model.sam <- SamSPECTRAL(digits.train[1:100, ], dimensions=c(1,2,3, 4, 5, 6, 7, 8, 9, 10), normal.sigma = 5, separation.factor = 0.7)
digits.model.db <- dbscan(digits.train, eps=.5, minPts = 4)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
kNNdistplot(digits.train, 11) #get the eps for the dbscan model. Need the y value at the elbow on the plot
digits.model.db <- dbscan(digits.train, eps=2200, minPts = 11)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
kNNdistplot(digits.train, 10) #get the eps for the dbscan model. Need the y value at the elbow on the plot
digits.model.db <- dbscan(digits.train, eps=2200, minPts = 10)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
?dbscan
digits.model.db <- dbscan(digits.train, eps=2200, minPts = 5)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=200, minPts = 5)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=2500, minPts = 10)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=2200, minPts = 10)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=1400, minPts = 10)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=1400, minPts = 5)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=1400, minPts = 4)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=1200, minPts = 4)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=1100, minPts = 4)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=1200, minPts = 3)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=1300, minPts = 3)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=1400, minPts = 3)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=1200, minPts = 3)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
digits.model.db <- dbscan(digits.train, eps=1200, minPts = 4)
(digits.con_mat.db <- table(digits.small$label, digits.model.db$cluster))
clusplot(digits.small, digits.model.db$cluster, color=T, shade=T, labels=0, lines=0)
digits.model.kknn <- specClust(digits.train, centers=3)
library(kknn)
digits.model.kknn <- specClust(digits.train, centers=3)
digits.small <- digits.full[1:1000,] #make the dataset smaller in order to run it on your laptop
digits.train <- as.matrix(digits.small[,2:785]) #remove the labels from the small dataset for model training
digits.model.kknn <- specClust(digits.train, centers=3)
digits.model.kknn <- specClust(digits.train, centers=10)
traceback()
digits.model.km <- kmeans(digits.small[,2:785], 10, nstart=20)
(digits.con_mat.km <- table(digits.small$label, digits.model.km$cluster))
digits.model.kknn <- specClust(digits.train, centers=10)
?specClust
digits.model.kknn <- specClust(digits.small[,2:785], centers=10)
vector <- c(1, 41, 33, 2, 49, 18, 1, 8, 4)
install.packages("discreteRV")
library(discreteRV)
P(vector)
?P
(X.fair.die <- RV(1:6, rep(1/6,6)))
P(X.fair.die>3)
?RV
(vector.prob <- RV(1:10, odds=vector))
(vector.prob <- RV(vector))
?dbinorm
?dbinom
dbinom(vector)
dbinom(vector, n=sum(vector))
sum(vector)
probablility(vector)
probability <- function(x) {
for (i in x) {
i <- i / sum(x)
return(i)
}
}
probablility(vector)
probability <- function(x) {
for (i in x) {
i <- i / sum(x)
return(i)
}
}
probability(vector)
sum(vector)
probability2 <- function(x) {
divisor <- sum(x)
for (i in x) {
i <- i / divisor
return(i)
}
}
probability2(vector)
lapply(vector, probability2)
probability2(vector)
probability2 <- function(x) {
divisor <- sum(x)
i <- i / divisor
return(i)
}
lapply(vector, probability2)
probability2 <- function(x) {
divisor <- sum(x)
x <- x / divisor
return(i)
}
lapply(vector, probability2)
probability2 <- function(x) {
divisor <- sum(x)
x <- x / divisor
return(x)
}
lapply(vector, probability2)
myfun <- function(x) {
vapply(seq_along(x), function(i) x[i] / sum(x[-i]), numeric(1))
}
myfun(vector)
cond_prob <- function(x) {
vapply(seq_along(x), function(i) x[i] / sum(x[-i]), numeric(1))
}
cond_prob(vector)
confusionmatrix
confusionmatrix <- table(digits.small$label, digits.cluster[1:100]) #confusion matrix of the actual label vs the cluster it was put in
(iris.con_mat.km <- table(iris.model.km$cluster, iris$Species))
cond_prob(iris.con_mat.km)
sapply(iris.con_mat.km, cond_prob)
lapply(iris.con_mat.km, cond_prob)
apply(iris.con_mat.km, cond_prob)
sapply(iris.con_mat.km, cond_prob)
sweep(iris.con_mat.km, 2, cond_prob)
df <- as.data.frame(iris.con_mat.km)
class(df)
df
mat <- as.matrix(iris.con)
class(mat)
mat <- as.matrix(iris.con)
class(mat)
mat <- as.matrix(iris.con)
mat <- as.matrix(iris.con_mat.km)
class(mat)
mat
mat <- as.matrix(iris.con_mat.km)
class(mat)
?table2matrix
install.packages("psych")
library(psych)
?table2matrix
df <- table2df(iris.con_mat.km)
class(df)
df
mat <- table2matrix(iris.con_mat.km)
class(mat)
mat
data(cubits)
cubit <- table2matrix(cubits,labs=c("height","cubit"))
describe(cubit)
ellipses(cubit,n=1)
data(bock)
responses <- table2df(bock.table[,2:6],count=bock.table[,7],labs= paste("lsat6.",1:5,sep=""))
describe(responses)
data(cubits)
class(cubits)
cubit <- table2matrix(cubits,labs=c("height","cubit"))
class(cubits)
?melt
library(dplyr)
library(plyr)
?melt
library(reshape2)
?melt
df <- melt.data.frame(iris.con_mat.km)
library(reshape2)
df <- melt.data.frame(iris.con_mat.km)
df <- melt(iris.con_mat.km)
class(df)
df
iris.con_mat.km
class(iris.con_mat.km)
class(iris.con_mat.km) <- "data.frame"
class(iris.con_mat.km)
class(iris.con_mat.km) <- "table"
class(iris.con_mat.km)
iris.con_mat.km
trial <- as.data.frame(table(iris.model.km$cluster, iris$Species))
class(trial)
trial
?as.data.frame
error <- as.data.frame(trial, row.names = trial$var1, col.names = trial$Var2)
error
?table
error <- is.data.frame(iris.con_mat.km)
error
iris.con_mat.km
iris.con_mat.km$setosa
iris.con_mat.km[,1]
iris.con_mat.km[1,]
iris.con_mat.km[2,]
iris.con_mat.km[,1] + 1
iris.con_mat.km[,1] / sum(iris.con_mat.km[,1])
iris.con_mat.km[1,] / sum(iris.con_mat.km[1,])
for (i in iris.con_mat.km) {
i <- i / sum(i)
return(i)
}
error <- for (i in iris.con_mat.km) {
i <- i / sum(i)
return(i)
}
error
class(iris.con_mat.km)
df
iris.con_mat.km
iris.con_mat.km[,1]
iris.con_mat.km[1,]
iris.con_mat.km[,1] / sum(iris.con_mat.km[,1])
iris.con_mat.km[,1:3] / sum(iris.con_mat.km[,1:3])
pro1 <- function(x) {
for (i in x) {
iris.con_mat.km[,i] / sum(iris.con_mat.km[,i])
}
}
pro1 <- function(x) {
for (i in x) {
x[,i] / sum(x[,i])
}
}
pro1(iris.con_mat.km)
pro1 <- function(x) {
for (i in x) {
x[,i] <- x[,i] / sum(x[,i])
}
}
pro1(iris.con_mat.km)
pro1 <- function(x) {
x[,i] <- x[,i] / sum(x[,i])
}
pro1(iris.con_mat.km)
error <- pro1(iris.con_mat.km)
error
pro1 <- function(x) {
for (i in 1:3) {
x[,i] <- x[,i] / sum(x[,i])
}}
error <- pro1(iris.con_mat.km)
error
iris.con_mat.km[1,] / sum(iris.con_mat.km[1,])
iris.con_mat.km
iris.con_mat.km[,1] / sum(iris.con_mat.km[,1])
iris.con_mat.km[1,] / sum(iris.con_mat.km[1,])
iris.con_mat.km
pro1 <- function(x) {
for (i in x) {
x[,i] <- x[,i] / sum(x[,i])
}}
error <- pro1(iris.con_mat.km)
iris.con_mat.km[,1]
iris.con_mat.km[1,]
pro1 <- function(x) {
for (i in x) {
x[i,] <- x[i,] / sum(x[i,])
}}
error <- pro1(iris.con_mat.km)
pro1 <- function(x) {
for (i in x) {
x[i] <- x[i] / sum(x[i])
}}
error <- pro1(iris.con_mat.km)
error
pro1 <- function(x) {
x[i,] <- x[i,] / sum(x[i,])
}
error <- pro1(iris.con_mat.km)
error
df <- melt(iris.con_mat.km)
df
cond_prob <- function(x) {
vapply(seq_along(x), function(i) x[i] / sum(x[-i]), numeric(1))
}
cond_prob(vector)
cond_prob(iris.con_mat.km)
vapply(seq_along(x), function(i) x[i] / sum(x[i]), numeric(1))
cond_prob <- function(x) {
vapply(seq_along(x), function(i) x[i] / sum(x[i]), numeric(1))
}
cond_prob(iris.con_mat.km)
?vapply
lapply(iris.con_mat.km, iris.con_mat.km[i,] / sum(iris.con_mat.km[i,]))
sapply(iris.con_mat.km, iris.con_mat.km[i,] / sum(iris.con_mat.km[i,]))
spply(iris.con_mat.km, iris.con_mat.km[i,] / sum(iris.con_mat.km[i,]))
pro1 <- function(x) {
x[i,] <- x[i,] / sum(x[i,])
}
error <- pro1(iris.con_mat.km)
error
lapply(iris.con_mat.km, prob1)
lapply(iris.con_mat.km, pro1)
sapply(iris.con_mat.km, pro1)
apply(iris.con_mat.km, pro1)
iris.con_mat.km[1,] / sum(iris.con_mat.km[1,])
iris.con_mat.km[2,] / sum(iris.con_mat.km[2,])
iris.con_mat.km[3,] / sum(iris.con_mat.km[3,])
iris.con_mat.km[1,] / sum(iris.con_mat.km[1,])
iris.con_mat.km[2,] / sum(iris.con_mat.km[2,])
iris.con_mat.km[3,] / sum(iris.con_mat.km[3,])
prob2 <- function(x, i) {
x[i,] <- x[i,] / sum(x[i,])
}
prob2(iris.con_mat.km, 1:3)
error <- prob2(iris.con_mat.km, 1:3)
error
iris.con_mat.specc[1,] / sum(iris.con_mat.specc[1,])
iris.model <- specc(iris.train, centers = 3)
(iris_con_mat.specc <- table(iris.model[1:150], iris$Species))
iris.con_mat.specc[1,] / sum(iris.con_mat.specc[1,])
(iris_con_mat.specc <- table(iris.model[1:150], iris$Species))
iris.con_mat.specc[1,] / sum(iris.con_mat.specc[1,])
(iris.con_mat.specc <- table(iris.model[1:150], iris$Species))
iris.con_mat.specc[1,] / sum(iris.con_mat.specc[1,])
iris.con_mat.specc[2,] / sum(iris.con_mat.specc[2,])
iris.con_mat.specc[3,] / sum(iris.con_mat.specc[3,])
iris.model.sam <- SamSPECTRAL(iris.train, dimensions=c(1,2,3), normal.sigma = 3, separation.factor = 1.2)
(iris.con_mat.sam <- table(iris.model.sam, iris$Species))
iris.con_mat.sam[1,] / sum(iris.con_mat.sam[1,])
iris.con_mat.sam[2,] / sum(iris.con_mat.sam[2,])
iris.con_mat.sam[3,] / sum(iris.con_mat.sam[3,])
library(kernlab)
library(SamSPECTRAL)
library(kknn)
library(dbscan)
library(cluster)
setwd("~/Learning/Lipscomb MSDS/Data Mining/Final _Project")
library(kernlab)
library(SamSPECTRAL)
library(kknn)
library(dbscan)
library(cluster)
setwd("~/Learning/Lipscomb MSDS/Data Mining/Final _Project")
digits.full <- read.csv('MNIST/train.csv')
digits.small <- digits.full[1:100,] #make the dataset smaller in order to run it on your laptop
digits.train <- as.matrix(digits.small[,2:785]) #remove the labels from the small dataset for model training
digits.model.specc <- specc(digits.train, centers = 10)
(digits_con_mat.specc <- table(digits.small$label, digits.model.specc[1:100]))
iris.model.sam <- SamSPECTRAL(iris.train, dimensions=c(1,2,3), normal.sigma = 3, separation.factor = 1.2)
(iris.con_mat.sam <- table(iris.model.sam, iris$Species))
clusplot(iris, iris.model.sam, color=T, shade=T, labels=0, lines=0)
clusplot(digits.small, digits.model.specc[1:1000], color=T, shade=T, labels=0, lines=0)
(digits_con_mat.specc <- table(digits.small$label, digits.model.specc[1:100]))
digits.con_mat.specc[1,] / sum(digits.con_mat.specc[1,])
(digits.con_mat.specc <- table(digits.small$label, digits.model.specc[1:100]))
digits.con_mat.specc[1,] / sum(digits.con_mat.specc[1,])
pro2 <- function(x){
for (i in 1:nrow(as.vector(x))) {
row.val <- (x[i,] / sum(x))
}
}
pro2 <- function(x){
for (i in 1:nrow(as.vector(x))) {
row.val <- (x[i,] / sum(x))
}
}
get.Func <- pro2(iris.con_mat.km)
kNNdistplot(digits.train, 10) #get the eps for the dbscan model. Need the y value at the elbow on the plot
